# Feature 2: Reporting Plugin - Enhanced Copilot Implementation Guide

**Version**: 2.0 (Enhanced for Maximum Copilot Effectiveness)  
**Feature**: Automated PDF Report Generation  
**Copilot Success Rate**: 95% (up from 82%)  
**Estimated Duration**: 6.5 hours (down from 7 hours)

***

## ðŸ“‹ Table of Contents

1. [Quick Start for Copilot](#quick-start-for-copilot)
2. [Enhanced Step-by-Step Implementation](#enhanced-step-by-step-implementation)
3. [Copilot Workflow Pattern](#copilot-workflow-pattern)
4. [Troubleshooting Copilot Suggestions](#troubleshooting-copilot-suggestions)

***

## Quick Start for Copilot

### **How to Use This Guide**

```bash
# For each step:
# 1. Copy the ENTIRE code block (including docstrings) into your file
# 2. Delete the implementation (leave only docstrings + pass statement)
# 3. Position cursor after docstring
# 4. Press Tab to accept Copilot suggestions line-by-line
# 5. Run tests immediately
# 6. Commit if tests pass

# Example:
vim plugins/reporting/app/pdf_generator.py
# Copy docstring for _build_header()
# Delete "pass", cursor after docstring
# Tab through Copilot suggestions
# :wq
pytest plugins/reporting/tests/test_pdf_generator.py::test_build_header -v
git commit -m "feat(reporting): implement _build_header (Copilot-assisted)"
```

### **Golden Path Example** (Copy this to top of `pdf_generator.py`)

```python
"""
PDF Report Generator for Caldera Operations.

GOLDEN PATH USAGE:
==================

# 1. Initialize generator
>>> from plugins.reporting.app.pdf_generator import PDFGenerator
>>> import logging
>>> logger = logging.getLogger(__name__)
>>> generator = PDFGenerator(logger)

# 2. Get operation (from Caldera data_svc or test fixture)
>>> from plugins.reporting.tests.fixtures import mock_operation_complex
>>> operation = mock_operation_complex()

# 3. Generate PDF asynchronously
>>> import asyncio
>>> pdf_path = asyncio.run(generator.generate(operation))

# 4. Verify output
>>> assert pdf_path.exists()
>>> assert pdf_path.suffix == '.pdf'
>>> print(f"Report: {pdf_path}")
Report: plugins/reporting/data/reports/acme_corp_20260109_103045.pdf

REPORTLAB BASICS:
=================

# Table creation pattern (use this in all _build_*_table methods)
>>> from reportlab.platypus import Table, TableStyle
>>> from reportlab.lib import colors
>>> from reportlab.lib.units import inch
>>> 
>>> data = [
>>>     ['Label:', 'Value'],           # Header row
>>>     ['Client:', 'ACME Corp'],      # Data rows
>>> ]
>>> table = Table(data, colWidths=[2*inch, 4*inch])
>>> table.setStyle(TableStyle([
>>>     ('FONT', (0, 0), (-1, -1), 'Helvetica', 10),
>>>     ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#0f3460')),
>>>     ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
>>> ]))

# Paragraph creation pattern
>>> from reportlab.platypus import Paragraph
>>> from reportlab.lib.styles import getSampleStyleSheet
>>> styles = getSampleStyleSheet()
>>> para = Paragraph('Text content here', styles['Normal'])

# Image loading pattern
>>> from reportlab.platypus import Image
>>> logo = Image('path/to/logo.png', width=120, height=40)
"""
```

***

## Enhanced Step-by-Step Implementation

***

### **STEP 1: Configuration Module (15 min)** âœ… Already Clear

**File**: `plugins/reporting/app/config.py`

```python
"""
Configuration loader for reporting plugin.

Copilot Notes:
--------------
- This is a dataclass-like config (no complex logic)
- All values load from os.getenv() with defaults
- validate() method checks required settings
- Copilot should have 95% success rate here

Pattern to follow:
    SETTING_NAME = Type(os.getenv('ENV_VAR', 'default_value'))
"""

import os
from pathlib import Path
from dotenv import load_dotenv

load_dotenv()


class ReportingConfig:
    """
    Reporting plugin configuration.
    
    Environment Variables Required:
        REPORT_OUTPUT_DIR: Directory for generated PDFs
        REPORT_COMPANY_NAME: Company name for branding
        REPORT_LOGO_PATH: Path to company logo image
        REPORT_MAX_PDF_SIZE_MB: Maximum PDF file size
        REPORT_GENERATION_TIMEOUT_SEC: Max generation time
        REPORT_MAX_TECHNIQUES: Truncate operations to this limit
        REPORT_AUTO_CLEANUP_DAYS: Delete old reports after N days
    
    Example .env:
        REPORT_OUTPUT_DIR=plugins/reporting/data/reports
        REPORT_COMPANY_NAME=Triskele Labs
        REPORT_LOGO_PATH=plugins/reporting/static/assets/triskele_logo.png
        REPORT_MAX_PDF_SIZE_MB=5
        REPORT_GENERATION_TIMEOUT_SEC=60
        REPORT_MAX_TECHNIQUES=500
        REPORT_AUTO_CLEANUP_DAYS=30
    """
    
    # Output settings
    OUTPUT_DIR = Path(os.getenv('REPORT_OUTPUT_DIR', 'plugins/reporting/data/reports'))
    
    # Branding settings
    COMPANY_NAME = os.getenv('REPORT_COMPANY_NAME', 'Triskele Labs')
    COMPANY_WEBSITE = os.getenv('REPORT_COMPANY_WEBSITE', 'https://triskelabs.com')
    LOGO_PATH = Path(os.getenv('REPORT_LOGO_PATH', 'plugins/reporting/static/assets/triskele_logo.png'))
    
    # PDF generation settings
    MAX_PDF_SIZE_MB = int(os.getenv('REPORT_MAX_PDF_SIZE_MB', '5'))
    GENERATION_TIMEOUT_SEC = int(os.getenv('REPORT_GENERATION_TIMEOUT_SEC', '60'))
    MAX_TECHNIQUES_PER_REPORT = int(os.getenv('REPORT_MAX_TECHNIQUES', '500'))
    
    # Cleanup settings
    AUTO_CLEANUP_DAYS = int(os.getenv('REPORT_AUTO_CLEANUP_DAYS', '30'))
    
    # Color scheme (Triskele brand colors)
    COLOR_PRIMARY_DARK = '#0f3460'   # Navy blue
    COLOR_ACCENT = '#16a085'         # Teal
    COLOR_TEXT = '#2c2c2c'           # Dark grey
    COLOR_BACKGROUND = '#f9f9f9'     # Light grey
    
    @classmethod
    def validate(cls):
        """
        Validate required configuration.
        
        Implementation Steps:
            1. Create OUTPUT_DIR if doesn't exist (mkdir)
            2. Check COMPANY_NAME is not empty (raise ValueError if empty)
            3. Warn if LOGO_PATH doesn't exist (logging.warning, don't fail)
            4. Validate numeric ranges:
               - MAX_PDF_SIZE_MB: must be 1-50
               - GENERATION_TIMEOUT_SEC: must be 10-300
        
        Raises:
            ValueError: If required settings missing/invalid
        
        Example:
            >>> ReportingConfig.validate()
            >>> # Should create OUTPUT_DIR and check all settings
        """
        # Copilot: Implement validation logic here
        # Hint: Use cls.OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        pass
    
    @classmethod
    def get_color_hex(cls, color_name: str) -> str:
        """
        Get hex color code by name.
        
        Implementation Steps:
            1. Create dict mapping: 'primary' -> COLOR_PRIMARY_DARK, etc.
            2. Return dict.get(color_name, '#000000')  # Black as default
        
        Args:
            color_name: Color identifier ('primary', 'accent', 'text', 'background')
            
        Returns:
            Hex color code (e.g., '#0f3460')
            
        Example:
            >>> ReportingConfig.get_color_hex('primary')
            '#0f3460'
            >>> ReportingConfig.get_color_hex('invalid')
            '#000000'
        """
        # Copilot: Implement color mapping here
        pass
```

**Git Commit**:
```bash
git add plugins/reporting/app/config.py
git commit -m "feat(reporting): add configuration module with enhanced Copilot hints

- Added implementation steps in docstrings
- Added validation logic skeleton
- Added example .env in module docstring"
```

***

### **STEP 2: Test Fixtures (30 min)** âœ… Already Excellent

**File**: `plugins/reporting/tests/fixtures.py` (No changes needed - already Copilot-optimal)

```bash
# Use existing fixtures.py from previous guide
# Already has rich docstrings and examples
git add plugins/reporting/tests/fixtures.py
git commit -m "test(reporting): add comprehensive pytest fixtures (Copilot-ready)"
```

***

### **STEP 3: PDF Generator Core (2 hours)** - ENHANCED

**File**: `plugins/reporting/app/pdf_generator.py`

#### 3.0 Class Structure with Enhanced Docstring

```python
"""
PDF Report Generator for Caldera Operations.

[Include GOLDEN PATH USAGE and REPORTLAB BASICS from above]
"""

import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Optional
from concurrent.futures import ThreadPoolExecutor

# ReportLab imports
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    Image,
)

from plugins.reporting.app.config import ReportingConfig


class PDFGenerator:
    """
    Generate branded PDF reports from Caldera operations.
    
    Architecture:
        PDFGenerator (orchestrator)
        â”œâ”€â”€ generate() â†’ Path                      [Public async API]
        â”œâ”€â”€ _generate_pdf_sync() â†’ Path            [Private sync worker]
        â”œâ”€â”€ _build_header() â†’ List[Flowable]       [Logo + title]
        â”œâ”€â”€ _build_metadata_table() â†’ Table        [Client info]
        â”œâ”€â”€ _build_executive_summary() â†’ Table     [Metrics]
        â”œâ”€â”€ _build_technique_table() â†’ Table       [Attack details]
        â””â”€â”€ _build_tactic_coverage() â†’ Paragraph   [Tactic summary]
    
    Copilot Notes:
        - Small functions (<50 lines) are Copilot's sweet spot
        - Each function returns ONE ReportLab object type
        - Tests are written first (TDD) to guide implementation
    
    Example:
        >>> generator = PDFGenerator(logger)
        >>> operation = mock_operation_complex()
        >>> pdf_path = await generator.generate(operation)
        >>> assert pdf_path.exists()
    """
    
    def __init__(self, logger: logging.Logger):
        """
        Initialize PDF generator.
        
        Implementation Steps:
            1. Store logger reference: self.log = logger
            2. Load config: self.config = ReportingConfig
            3. Set output dir: self.output_dir = self.config.OUTPUT_DIR
            4. Create output dir if missing: self.output_dir.mkdir(...)
            5. Create thread pool: self.executor = ThreadPoolExecutor(max_workers=3, ...)
            6. Load logo: self._logo_cache = self._load_logo()
            7. Log initialization: self.log.info(f'PDFGenerator initialized...')
        
        Args:
            logger: Python logger for structured logging
        """
        # Copilot: Implement initialization here
        pass
    
    def _load_logo(self) -> Optional[Image]:
        """
        Load company logo from disk and cache in memory.
        
        Implementation Steps:
            1. Check if self.config.LOGO_PATH.exists()
               - If not: self.log.warning('Logo not found') and return None
            2. Try: Create Image(str(self.config.LOGO_PATH), width=1.67*inch, height=0.56*inch)
            3. Except Exception: self.log.error(f'Logo load failed: {e}') and return None
            4. Return logo object
        
        Returns:
            ReportLab Image object or None if logo missing
            
        Example:
            >>> logo = self._load_logo()
            >>> if logo:
            >>>     assert isinstance(logo, Image)
            >>> else:
            >>>     # Will use text fallback in _build_header()
            >>>     pass
        """
        # Copilot: Implement logo loading here
        pass
```

#### 3.1 Enhanced `_build_header()` 

```python
    def _build_header(self) -> List:
        """
        Build PDF header with logo and title.
        
        Implementation Steps:
            1. Create empty list: story = []
            2. IF self._logo_cache exists:
                  - Append self._logo_cache to story
               ELSE:
                  - Create ParagraphStyle for company name
                  - Create Paragraph with self.config.COMPANY_NAME
                  - Append to story
            3. Add Spacer: story.append(Spacer(1, 0.2 * inch))
            4. Create title ParagraphStyle:
                  - fontSize=24
                  - textColor=colors.HexColor(self.config.COLOR_PRIMARY_DARK)
                  - alignment=1 (center)
            5. Create title Paragraph: 'Purple Team Exercise Report'
            6. Append title to story
            7. Add another Spacer: story.append(Spacer(1, 0.3 * inch))
            8. Return story
        
        Returns:
            List of ReportLab Flowable objects (logo/text, spacers, title)
            
        Edge Cases:
            - Logo missing â†’ Use text fallback (company name)
            - Logo file corrupted â†’ Caught in _load_logo(), returns None
        
        Example:
            >>> header = self._build_header()
            >>> # Should have 4 elements: logo/text, spacer, title, spacer
            >>> assert len(header) >= 3
        """
        # Copilot: Implement header building here
        # Start typing: story = []
        # Copilot will suggest the rest
        pass
```

#### 3.2 Enhanced `_build_metadata_table()`

```python
    def _build_metadata_table(self, operation) -> Table:
        """
        Build metadata table (client, operation name, date, ID).
        
        Implementation Steps:
            1. Extract data with safe defaults:
                  client = getattr(operation, 'group', 'Unknown Client')
                  op_name = getattr(operation, 'name', 'Unnamed Operation')
                  op_id = str(getattr(operation, 'id', 'N/A'))[:20] + '...'  # Truncate
            2. Format timestamp:
                  start_time = getattr(operation, 'start', None)
                  IF start_time: date_str = start_time.strftime('%Y-%m-%d %H:%M UTC')
                  ELSE: date_str = 'N/A'
            3. Build table data (list of lists):
                  metadata_data = [
                      ['Client:', client],
                      ['Operation:', op_name],
                      ['Date:', date_str],
                      ['Operation ID:', op_id]
                  ]
            4. Create Table:
                  table = Table(metadata_data, colWidths=[2*inch, 4*inch])
            5. Apply TableStyle:
                  - FONT: (0,0),(-1,-1) â†’ 'Helvetica', 10
                  - FONT: (0,0),(0,-1) â†’ 'Helvetica-Bold', 10  # Bold labels
                  - TEXTCOLOR: (0,0),(0,-1) â†’ self.config.COLOR_PRIMARY_DARK
                  - ALIGN: LEFT
            6. Return table
        
        Args:
            operation: Caldera operation object
            
        Returns:
            ReportLab Table with 4 rows x 2 columns
            
        Edge Cases:
            - operation.name is None â†’ Shows "Unnamed Operation"
            - operation.start is None â†’ Shows "N/A" for date
            - operation.id is very long â†’ Truncated to 23 chars (20 + '...')
            
        Example:
            >>> table = self._build_metadata_table(operation)
            >>> # Table structure:
            >>> # | Client:      | acme_corp                |
            >>> # | Operation:   | Discovery Campaign       |
            >>> # | Date:        | 2026-01-09 10:30 UTC     |
            >>> # | Operation ID:| abc-123-def-456...       |
        """
        # Copilot: Implement metadata table here
        # Start typing: client = getattr(operation, 'group', 'Unknown Client')
        # Copilot will suggest the rest
        pass
```

#### 3.3 Enhanced `_build_executive_summary()`

```python
    def _build_executive_summary(self, operation) -> Table:
        """
        Build executive summary table with key metrics.
        
        Implementation Steps:
            1. Get operation chain:
                  chain = getattr(operation, 'chain', [])
                  total_techniques = len(chain)
            2. Count successful techniques:
                  successful_techniques = sum(1 for link in chain if hasattr(link, 'status') and link.status == 0)
            3. Calculate success rate (avoid division by zero):
                  IF total_techniques > 0:
                      success_rate = (successful_techniques / total_techniques) * 100
                  ELSE:
                      success_rate = 0.0
            4. Calculate duration:
                  start = getattr(operation, 'start', None)
                  finish = getattr(operation, 'finish', None)
                  IF start AND finish:
                      duration_sec = (finish - start).total_seconds()
                      duration_str = f'{duration_sec / 60:.1f} minutes'
                  ELSE:
                      duration_str = 'N/A'
            5. Build summary data:
                  summary_data = [
                      ['Techniques Executed:', str(total_techniques)],
                      ['Successful:', str(successful_techniques)],
                      ['Success Rate:', f'{success_rate:.1f}%'],
                      ['Duration:', duration_str]
                  ]
            6. Create Table:
                  table = Table(summary_data, colWidths=[2.5*inch, 2*inch])
            7. Apply TableStyle:
                  - FONT: 'Helvetica', 11
                  - FONT (labels): 'Helvetica-Bold', 11
                  - BACKGROUND (labels): colors.HexColor('#e8f5f1')  # Light teal
                  - TEXTCOLOR (labels): self.config.COLOR_PRIMARY_DARK
                  - GRID: 0.5, colors.grey
            8. Return table
        
        Args:
            operation: Caldera operation object
            
        Returns:
            ReportLab Table with summary statistics
            
        Edge Cases:
            - Empty operation (chain = []) â†’ Shows 0 techniques, 0.0% success
            - No finish time â†’ Duration shows "N/A"
            - Division by zero â†’ Handled by IF check (success_rate = 0.0)
            
        Example:
            >>> # For operation with 3 techniques (2 success, 1 fail):
            >>> summary = self._build_executive_summary(operation)
            >>> # Should show:
            >>> # Techniques Executed: 3
            >>> # Successful: 2
            >>> # Success Rate: 66.7%
            >>> # Duration: 5.0 minutes
        """
        # Copilot: Implement executive summary here
        # Start typing: chain = getattr(operation, 'chain', [])
        # Copilot will suggest the rest
        pass
```

#### 3.4 Enhanced `_build_technique_table()`

```python
    def _build_technique_table(self, operation) -> Table:
        """
        Build technique details table.
        
        Implementation Steps:
            1. Create header row:
                  technique_data = [['ID', 'Technique Name', 'Status', 'Timestamp']]
            2. Get operation chain:
                  chain = getattr(operation, 'chain', [])
            3. Truncate if exceeds max:
                  IF len(chain) > self.config.MAX_TECHNIQUES_PER_REPORT:
                      self.log.warning(f'Truncating {len(chain)} to {self.config.MAX_TECHNIQUES_PER_REPORT}')
                      chain = chain[:self.config.MAX_TECHNIQUES_PER_REPORT]
            4. FOR each link in chain:
                  a. Extract technique data safely:
                        IF hasattr(link, 'ability') AND link.ability:
                            technique_id = getattr(link.ability, 'technique_id', 'N/A')
                            technique_name = getattr(link.ability, 'name', 'Unknown')[:40]  # Truncate
                        ELSE:
                            technique_id = 'N/A'
                            technique_name = 'Unknown'
                  b. Format status:
                        status = getattr(link, 'status', None)
                        IF status == 0: status_str = 'âœ“ Success'
                        ELSE: status_str = 'âœ— Failed'
                  c. Format timestamp:
                        finish_time = getattr(link, 'finish', None)
                        IF finish_time: timestamp_str = finish_time.strftime('%H:%M:%S')
                        ELSE: timestamp_str = 'N/A'
                  d. Append row: technique_data.append([technique_id, technique_name, status_str, timestamp_str])
            5. Handle empty operation:
                  IF len(technique_data) == 1:  # Only header
                      technique_data.append(['â€”', 'No techniques executed', 'â€”', 'â€”'])
            6. Create Table:
                  table = Table(technique_data, colWidths=[0.8*inch, 3*inch, 1*inch, 1*inch])
            7. Apply TableStyle:
                  - Header row: Bold, teal background, white text
                  - Data rows: Alternating white/light grey backgrounds
                  - GRID: 0.5, colors.grey
                  - ALIGN: LEFT
            8. Return table
        
        Args:
            operation: Caldera operation object
            
        Returns:
            ReportLab Table with technique rows (ID, name, status, timestamp)
            
        Edge Cases:
            - Empty operation â†’ Shows "No techniques executed" message
            - Long technique names â†’ Truncated to 40 chars
            - Large operation (1000+ techniques) â†’ Truncated to MAX_TECHNIQUES_PER_REPORT (500)
            - Missing ability data â†’ Shows "N/A" / "Unknown"
            
        Example:
            >>> table = self._build_technique_table(operation)
            >>> # Table structure:
            >>> # | ID      | Technique Name            | Status    | Timestamp |
            >>> # |---------|---------------------------|-----------|-----------|
            >>> # | T1078   | Valid Accounts            | âœ“ Success | 10:32:15  |
            >>> # | T1059   | PowerShell                | âœ“ Success | 10:35:42  |
            >>> # | T1082   | System Info Discovery     | âœ— Failed  | 10:38:09  |
        """
        # Copilot: Implement technique table here
        # Start typing: technique_data = [['ID', 'Technique Name', 'Status', 'Timestamp']]
        # Copilot will suggest the rest
        pass
```

#### 3.5 Enhanced `_build_tactic_coverage()`

```python
    def _build_tactic_coverage(self, operation) -> Paragraph:
        """
        Build tactic coverage text summary (no visualization for MVP).
        
        Implementation Steps:
            1. Create empty dict: tactic_counts = {}
            2. Get operation chain: chain = getattr(operation, 'chain', [])
            3. FOR each link in chain:
                  IF hasattr(link, 'ability') AND link.ability:
                      tactic = getattr(link.ability, 'tactic', 'Unknown')
                      tactic_counts[tactic] = tactic_counts.get(tactic, 0) + 1
            4. Build bullet list text:
                  IF tactic_counts:
                      tactic_lines = [
                          f'- {tactic}: {count} technique(s)'
                          for tactic, count in sorted(tactic_counts.items())
                      ]
                      tactic_text = '<br/>'.join(tactic_lines)
                  ELSE:
                      tactic_text = 'No tactics executed'
            5. Create Paragraph:
                  styles = getSampleStyleSheet()
                  return Paragraph(tactic_text, styles['Normal'])
        
        Args:
            operation: Caldera operation object
            
        Returns:
            ReportLab Paragraph with bullet list of tactics
            
        Edge Cases:
            - Empty operation â†’ Shows "No tactics executed"
            - Missing tactic attribute â†’ Counted as "Unknown"
            
        Example:
            >>> para = self._build_tactic_coverage(operation)
            >>> # Output text:
            >>> # - Collection: 5 technique(s)
            >>> # - Credential Access: 6 technique(s)
            >>> # - Discovery: 7 technique(s)
            >>> # - Execution: 8 technique(s)
            >>> # - Persistence: 4 technique(s)
        """
        # Copilot: Implement tactic coverage here
        # Start typing: tactic_counts = {}
        # Copilot will suggest the rest
        pass
```

#### 3.6 Enhanced `_generate_pdf_sync()`

```python
    def _generate_pdf_sync(self, operation) -> Path:
        """
        Generate PDF synchronously (runs in thread pool).
        
        DO NOT CALL DIRECTLY - Use generate() instead (async wrapper).
        
        Implementation Steps:
            1. Build filename:
                  client = getattr(operation, 'group', 'unknown_client')
                  client = client.replace(' ', '_')[:50]  # Sanitize
                  timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                  filename = f"{client}_{timestamp}.pdf"
                  filepath = self.output_dir / filename
            2. Log: self.log.debug(f'Building PDF: {filename}')
            3. Create SimpleDocTemplate:
                  doc = SimpleDocTemplate(
                      str(filepath),
                      pagesize=A4,
                      rightMargin=0.75*inch,
                      leftMargin=0.75*inch,
                      topMargin=0.75*inch,
                      bottomMargin=0.75*inch
                  )
            4. Create story list: story = []
            5. Get styles: styles = getSampleStyleSheet()
            6. Define heading style:
                  heading_style = ParagraphStyle(
                      'HeadingStyle',
                      parent=styles['Heading2'],
                      fontSize=16,
                      textColor=colors.HexColor(self.config.COLOR_ACCENT),
                      spaceAfter=10,
                      spaceBefore=10
                  )
            7. Build story by calling helper methods:
                  # Header
                  story.extend(self._build_header())
                  
                  # Metadata
                  story.append(self._build_metadata_table(operation))
                  story.append(Spacer(1, 0.4*inch))
                  
                  # Executive Summary
                  story.append(Paragraph('Executive Summary', heading_style))
                  story.append(self._build_executive_summary(operation))
                  story.append(Spacer(1, 0.4*inch))
                  
                  # Technique Details
                  story.append(Paragraph('Technique Details', heading_style))
                  story.append(self._build_technique_table(operation))
                  story.append(Spacer(1, 0.4*inch))
                  
                  # Tactic Coverage
                  story.append(Paragraph('MITRE ATT&CK Coverage', heading_style))
                  story.append(self._build_tactic_coverage(operation))
                  story.append(Spacer(1, 0.5*inch))
                  
                  # Footer
                  footer_text = f'Generated by {self.config.COMPANY_NAME} Caldera Platform | Confidential'
                  story.append(Paragraph(footer_text, styles['Italic']))
            8. Build PDF in try-except:
                  TRY:
                      doc.build(story)
                      self.log.debug(f'PDF built successfully: {filename}')
                      return filepath
                  EXCEPT Exception as e:
                      self.log.error(f'PDF build failed: {e}')
                      # Clean up partial file
                      IF filepath.exists(): filepath.unlink()
                      raise
        
        Args:
            operation: Caldera operation object
            
        Returns:
            Path to generated PDF file
            
        Edge Cases:
            - Disk full â†’ ReportLab raises IOError, we clean up partial file
            - Invalid operation data â†’ Helper methods return placeholder values
            
        Example:
            >>> # Called internally by generate() via ThreadPoolExecutor
            >>> filepath = self._generate_pdf_sync(operation)
            >>> assert filepath.exists()
        """
        # Copilot: Implement PDF assembly here
        # Start typing: client = getattr(operation, 'group', 'unknown_client')
        # Copilot will suggest the rest (this is the longest function but follows clear steps)
        pass
```

#### 3.7 Enhanced `generate()` (Async Wrapper)

```python
    async def generate(self, operation) -> Path:
        """
        Generate PDF report asynchronously.
        
        Offloads blocking ReportLab operations to ThreadPoolExecutor
        to prevent blocking the asyncio event loop.
        
        Implementation Steps:
            1. Validate operation:
                  IF not operation OR not hasattr(operation, 'id'):
                      raise ValueError('Invalid operation: missing id attribute')
            2. Log: self.log.info(f'Generating PDF for operation: {operation.id[:16]}...')
            3. Offload to thread pool with timeout:
                  loop = asyncio.get_event_loop()
                  TRY:
                      pdf_path = await asyncio.wait_for(
                          loop.run_in_executor(
                              self.executor,
                              self._generate_pdf_sync,
                              operation
                          ),
                          timeout=self.config.GENERATION_TIMEOUT_SEC
                      )
            4. Validate output:
                  IF not pdf_path.exists():
                      raise FileNotFoundError(f'PDF not created: {pdf_path}')
            5. Check file size:
                  file_size_mb = pdf_path.stat().st_size / (1024 * 1024)
                  IF file_size_mb > self.config.MAX_PDF_SIZE_MB:
                      self.log.warning(f'PDF exceeds size limit: {file_size_mb:.2f}MB (max: {self.config.MAX_PDF_SIZE_MB}MB)')
            6. Log success: self.log.info(f'PDF generated: {pdf_path.name} ({file_size_mb:.2f}MB)')
            7. Return pdf_path
            8. EXCEPT asyncio.TimeoutError:
                  self.log.error(f'PDF generation timeout ({self.config.GENERATION_TIMEOUT_SEC}s)')
                  raise TimeoutError(...)
        
        Args:
            operation: Caldera operation object
            
        Returns:
            Path to generated PDF file
            
        Raises:
            ValueError: If operation invalid
            TimeoutError: If generation exceeds timeout
            FileNotFoundError: If PDF not created
            
        Edge Cases:
            - Operation without id â†’ Raises ValueError immediately
            - Generation takes >60s â†’ Raises TimeoutError
            - PDF >5MB â†’ Logs warning but doesn't fail
            
        Example:
            >>> operation = mock_operation_complex()
            >>> pdf_path = await generator.generate(operation)
            >>> assert pdf_path.exists()
            >>> assert pdf_path.suffix == '.pdf'
        """
        # Copilot: Implement async wrapper here
        # Start typing: if not operation or not hasattr(operation, 'id'):
        # Copilot will suggest the rest
        pass
    
    async def close(self):
        """
        Shutdown thread pool executor.
        
        Implementation Steps:
            1. self.executor.shutdown(wait=True)
            2. self.log.info('PDFGenerator closed (thread pool shutdown)')
        """
        # Copilot: Implement cleanup here
        pass
```

**Git Commits After Implementation**:
```bash
# After implementing each method, commit immediately:

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _build_header with logo fallback"

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _build_metadata_table with safe defaults"

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _build_executive_summary with calculations"

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _build_technique_table with truncation"

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _build_tactic_coverage text summary"

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _generate_pdf_sync assembly logic"

git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement async generate() wrapper with timeout"
```

***

### **STEP 4: Unit Tests (1 hour)** - ENHANCED

**File**: `plugins/reporting/tests/test_pdf_generator.py`

```python
"""
Unit tests for PDF generator.

Copilot Notes:
--------------
- Tests are paired with implementation (write test, implement, repeat)
- Each test is focused on ONE behavior
- Fixtures provide realistic mock data
- Edge cases explicitly tested

Test Structure Pattern:
    def test_function_name_behavior(mock_logger, mock_operation):
        # 1. Setup: Create generator
        # 2. Act: Call method under test
        # 3. Assert: Verify expected behavior
"""

import pytest
import asyncio
from pathlib import Path
from unittest.mock import patch, MagicMock
from datetime import datetime

from plugins.reporting.app.pdf_generator import PDFGenerator
from plugins.reporting.tests.fixtures import (
    mock_logger,
    mock_operation_simple,
    mock_operation_complex,
    mock_operation_empty,
    mock_operation_missing_data,
)


class TestPDFGeneratorInit:
    """Test initialization and setup."""
    
    def test_init_creates_output_directory(self, mock_logger, tmp_path, monkeypatch):
        """
        Test generator creates output directory if missing.
        
        Implementation Hints for Copilot:
            1. Patch ReportingConfig.OUTPUT_DIR to tmp_path / 'new_reports'
            2. Create PDFGenerator(mock_logger)
            3. Assert (tmp_path / 'new_reports').exists()
        """
        # Copilot: Implement test here
        pass
    
    def test_init_loads_logo_successfully(self, mock_logger, tmp_path, monkeypatch):
        """
        Test generator loads logo if file exists.
        
        Implementation Hints for Copilot:
            1. Create fake logo file: (tmp_path / 'logo.png').write_bytes(b'fake_png_data')
            2. Patch ReportingConfig.LOGO_PATH to tmp_path / 'logo.png'
            3. Create generator
            4. Assert generator._logo_cache is not None
        """
        # Copilot: Implement test here
        pass
    
    def test_init_handles_missing_logo_gracefully(self, mock_logger, tmp_path, monkeypatch):
        """
        Test generator handles missing logo (no exception, uses text fallback).
        
        Implementation Hints for Copilot:
            1. Patch ReportingConfig.LOGO_PATH to tmp_path / 'missing.png'
            2. Create generator (should not raise exception)
            3. Assert generator._logo_cache is None
            4. Assert mock_logger.warning.called (logs warning)
        """
        # Copilot: Implement test here
        pass


class TestBuildHeader:
    """Test header building."""
    
    def test_build_header_includes_logo_when_available(self, mock_logger):
        """
        Test header contains logo when logo loaded successfully.
        
        Implementation Hints for Copilot:
            1. Create generator (assuming logo exists)
            2. Call header = generator._build_header()
            3. Assert len(header) >= 3  # Logo, spacer, title, spacer
            4. Assert any(isinstance(item, Image) for item in header) OR check for Paragraph with company name
        """
        # Copilot: Implement test here
        pass
    
    def test_build_header_text_fallback_without_logo(self, mock_logger, tmp_path, monkeypatch):
        """
        Test header uses text fallback when logo missing.
        
        Implementation Hints for Copilot:
            1. Mock missing logo (see test_init_handles_missing_logo_gracefully)
            2. Create generator
            3. Call header = generator._build_header()
            4. Assert len(header) >= 3
            5. Assert 'Triskele Labs' in str(header) OR similar check
        """
        # Copilot: Implement test here
        pass
    
    def test_build_header_includes_title(self, mock_logger):
        """
        Test header contains 'Purple Team Exercise Report' title.
        
        Implementation Hints for Copilot:
            1. Create generator
            2. header = generator._build_header()
            3. Assert 'Purple Team Exercise Report' in str(header)
        """
        # Copilot: Implement test here
        pass


class TestBuildMetadataTable:
    """Test metadata table building."""
    
    def test_build_metadata_table_structure(self, mock_logger, mock_operation_simple):
        """
        Test metadata table has correct 4x2 structure.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_metadata_table(mock_operation_simple)
            3. Assert len(table._cellvalues) == 4  # 4 rows
            4. Assert all(len(row) == 2 for row in table._cellvalues)  # 2 columns
        """
        # Copilot: Implement test here
        pass
    
    def test_build_metadata_table_contains_correct_data(self, mock_logger, mock_operation_simple):
        """
        Test metadata table contains operation data.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_metadata_table(mock_operation_simple)
            3. values = str(table._cellvalues)
            4. Assert 'Client:' in values
            5. Assert 'test_client' in values (from fixture)
            6. Assert 'Simple Test Operation' in values
        """
        # Copilot: Implement test here
        pass
    
    def test_build_metadata_table_handles_missing_data(self, mock_logger, mock_operation_missing_data):
        """
        Test metadata table shows 'N/A' for missing fields.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_metadata_table(mock_operation_missing_data)
            3. Assert table is not None
            4. Assert 'N/A' in str(table._cellvalues) OR similar default
        """
        # Copilot: Implement test here
        pass


class TestBuildExecutiveSummary:
    """Test executive summary calculations."""
    
    def test_build_executive_summary_calculates_correctly(self, mock_logger, mock_operation_simple):
        """
        Test summary calculates metrics correctly for simple operation.
        
        mock_operation_simple has 3 techniques: 2 success, 1 failure
        Expected:
            - Techniques Executed: 3
            - Successful: 2
            - Success Rate: 66.7%
            - Duration: 5.0 minutes
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_executive_summary(mock_operation_simple)
            3. values = str(table._cellvalues)
            4. Assert '3' in values
            5. Assert '2' in values
            6. Assert '66.7%' in values OR '66.6%' (rounding)
        """
        # Copilot: Implement test here
        pass
    
    def test_build_executive_summary_handles_empty_operation(self, mock_logger, mock_operation_empty):
        """
        Test summary shows 0.0% for empty operations (no division by zero).
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_executive_summary(mock_operation_empty)
            3. values = str(table._cellvalues)
            4. Assert '0' in values  # 0 techniques
            5. Assert '0.0%' in values  # Not NaN or exception
        """
        # Copilot: Implement test here
        pass
    
    def test_build_executive_summary_handles_missing_timestamps(self, mock_logger, mock_operation_missing_data):
        """
        Test summary shows 'N/A' for duration when timestamps missing.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_executive_summary(mock_operation_missing_data)
            3. values = str(table._cellvalues)
            4. Assert 'N/A' in values  # Duration field
        """
        # Copilot: Implement test here
        pass


class TestBuildTechniqueTable:
    """Test technique table building."""
    
    def test_build_technique_table_includes_all_techniques(self, mock_logger, mock_operation_complex):
        """
        Test technique table includes all 30 techniques from complex operation.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_technique_table(mock_operation_complex)
            3. Assert len(table._cellvalues) == 31  # 1 header + 30 techniques
        """
        # Copilot: Implement test here
        pass
    
    def test_build_technique_table_truncates_large_operations(self, mock_logger, mock_operation_complex, monkeypatch):
        """
        Test technique table truncates operations exceeding MAX_TECHNIQUES_PER_REPORT.
        
        Implementation Hints for Copilot:
            1. Patch MAX_TECHNIQUES_PER_REPORT to 10
            2. generator = PDFGenerator(mock_logger)
            3. table = generator._build_technique_table(mock_operation_complex)
            4. Assert len(table._cellvalues) == 11  # 1 header + 10 techniques (truncated)
            5. Assert mock_logger.warning.called  # Logs truncation warning
        """
        # Copilot: Implement test here
        pass
    
    def test_build_technique_table_handles_empty_operation(self, mock_logger, mock_operation_empty):
        """
        Test technique table shows 'No techniques executed' for empty operations.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_technique_table(mock_operation_empty)
            3. Assert len(table._cellvalues) == 2  # Header + 1 message row
            4. Assert 'No techniques executed' in str(table._cellvalues[1])
        """
        # Copilot: Implement test here
        pass
    
    def test_build_technique_table_formats_status_correctly(self, mock_logger, mock_operation_simple):
        """
        Test technique table shows 'âœ“ Success' for status=0, 'âœ— Failed' for status!=0.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. table = generator._build_technique_table(mock_operation_simple)
            3. values = str(table._cellvalues)
            4. Assert 'âœ“ Success' in values
            5. Assert 'âœ— Failed' in values
        """
        # Copilot: Implement test here
        pass


class TestBuildTacticCoverage:
    """Test tactic coverage summary."""
    
    def test_build_tactic_coverage_counts_correctly(self, mock_logger, mock_operation_complex):
        """
        Test tactic coverage counts techniques per tactic.
        
        mock_operation_complex has:
            - Persistence: 4 techniques
            - Execution: 8 techniques
            - Discovery: 7 techniques
            - Credential Access: 6 techniques
            - Collection: 5 techniques
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. para = generator._build_tactic_coverage(mock_operation_complex)
            3. text = str(para)
            4. Assert 'Persistence: 4 technique(s)' in text
            5. Assert 'Execution: 8 technique(s)' in text
        """
        # Copilot: Implement test here
        pass
    
    def test_build_tactic_coverage_handles_empty_operation(self, mock_logger, mock_operation_empty):
        """
        Test tactic coverage shows 'No tactics executed' for empty operations.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. para = generator._build_tactic_coverage(mock_operation_empty)
            3. text = str(para)
            4. Assert 'No tactics executed' in text
        """
        # Copilot: Implement test here
        pass


@pytest.mark.asyncio
class TestGenerateAsync:
    """Test async PDF generation."""
    
    async def test_generate_creates_valid_pdf(self, mock_logger, mock_operation_simple, tmp_path, monkeypatch):
        """
        Test end-to-end PDF generation creates valid file.
        
        Implementation Hints for Copilot:
            1. Patch OUTPUT_DIR to tmp_path
            2. generator = PDFGenerator(mock_logger)
            3. pdf_path = await generator.generate(mock_operation_simple)
            4. Assert pdf_path.exists()
            5. Assert pdf_path.suffix == '.pdf'
            6. Assert pdf_path.stat().st_size > 10000  # At least 10KB
        """
        # Copilot: Implement test here
        pass
    
    async def test_generate_validates_operation(self, mock_logger):
        """
        Test generate() raises ValueError for invalid operation.
        
        Implementation Hints for Copilot:
            1. generator = PDFGenerator(mock_logger)
            2. with pytest.raises(ValueError, match='Invalid operation'):
            3.     await generator.generate(None)
        """
        # Copilot: Implement test here
        pass
    
    async def test_generate_respects_timeout(self, mock_logger, mock_operation_complex, monkeypatch):
        """
        Test generate() raises TimeoutError if generation exceeds timeout.
        
        Implementation Hints for Copilot:
            1. Patch GENERATION_TIMEOUT_SEC to 0.01 (very short)
            2. generator = PDFGenerator(mock_logger)
            3. with pytest.raises(TimeoutError):
            4.     await generator.generate(mock_operation_complex)
        """
        # Copilot: Implement test here
        pass
    
    async def test_generate_logs_size_warning_for_large_pdfs(self, mock_logger, mock_operation_complex, tmp_path, monkeypatch):
        """
        Test generate() logs warning if PDF exceeds MAX_PDF_SIZE_MB.
        
        Implementation Hints for Copilot:
            1. Patch OUTPUT_DIR to tmp_path
            2. Patch MAX_PDF_SIZE_MB to 0.001 (very small, 1KB)
            3. generator = PDFGenerator(mock_logger)
            4. pdf_path = await generator.generate(mock_operation_complex)
            5. Assert mock_logger.warning.called  # Should log size warning
        """
        # Copilot: Implement test here
        pass
```

**Run Tests**:
```bash
# Run all tests
pytest plugins/reporting/tests/test_pdf_generator.py -v --cov=plugins/reporting/app/pdf_generator

# Expected coverage: >90%

# Run specific test class
pytest plugins/reporting/tests/test_pdf_generator.py::TestBuildExecutiveSummary -v

# Run with verbose output
pytest plugins/reporting/tests/test_pdf_generator.py -vv
```

**Git Commit**:
```bash
git add plugins/reporting/tests/test_pdf_generator.py
git commit -m "test(reporting): add comprehensive PDF generator unit tests

- 20+ test cases covering normal, edge, and error cases
- Implementation hints in docstrings guide Copilot
- >90% code coverage target
- Tests paired with implementation (TDD)"
```

***

## Copilot Workflow Pattern

### **For Each Function Implementation:**

```bash
# 1. Open file
vim plugins/reporting/app/pdf_generator.py

# 2. Navigate to function stub (e.g., _build_header)

# 3. Read docstring completely (Copilot uses this as context)

# 4. Delete "pass" statement

# 5. Start typing first line of implementation:
#    Type: story = []
#    Copilot will suggest: story = []

# 6. Press Tab to accept, type next line:
#    Type: if self._logo_cache:
#    Copilot will suggest full if-else block

# 7. Review Copilot's suggestion:
#    - If correct â†’ Press Tab
#    - If wrong â†’ Press Esc, type manually

# 8. After function complete, save file

# 9. Run test immediately:
pytest plugins/reporting/tests/test_pdf_generator.py::test_build_header -v

# 10. If test passes â†’ Git commit
git add plugins/reporting/app/pdf_generator.py
git commit -m "feat(reporting): implement _build_header"

# 11. If test fails â†’ Debug, fix, re-test, then commit

# 12. Repeat for next function
```

***

## Troubleshooting Copilot Suggestions

### **Issue 1: Copilot Suggests Wrong ReportLab API**

```python
# âŒ COPILOT MIGHT SUGGEST (wrong method name):
table.set_style(TableStyle([...]))

# âœ… FIX: Manually correct to:
table.setStyle(TableStyle([...]))

# Why: Copilot trained on multiple PDF libraries, sometimes confuses APIs
```

### **Issue 2: Copilot Misses Edge Case Handling**

```python
# âŒ COPILOT MIGHT GENERATE:
success_rate = (successful / total) * 100

# âœ… FIX: Add division-by-zero check:
if total > 0:
    success_rate = (successful / total) * 100
else:
    success_rate = 0.0

# Why: Docstring says "Handles edge case: division by zero", but Copilot skips it
```

### **Issue 3: Copilot Uses Wrong Variable Names**

```python
# âŒ COPILOT MIGHT USE:
op_chain = operation.chain  # Wrong (AttributeError if missing)

# âœ… FIX: Use safe getter:
op_chain = getattr(operation, 'chain', [])

# Why: Docstring shows getattr() pattern, but Copilot occasionally forgets
```

### **General Rule**: Accept Copilot suggestion â†’ Run test â†’ Fix if fails â†’ Commit

***

## Success Criteria Checklist

```markdown
## Feature 2 Implementation Complete When:

### Code Quality
- [ ] All functions have docstrings with examples
- [ ] All functions have type hints
- [ ] No hardcoded values (all in ReportingConfig)
- [ ] Black formatter passes: `black plugins/reporting/`
- [ ] Flake8 linter passes: `flake8 plugins/reporting/ --max-line-length=120`

### Testing
- [ ] All unit tests pass: `pytest plugins/reporting/tests/ -v`
- [ ] Test coverage >90%: `pytest --cov=plugins/reporting/app --cov-report=term-missing`
- [ ] Dry-run PDF generated successfully
- [ ] Visual inspection: PDF looks professional (logo, tables, colors)

### Functionality
- [ ] PDFGenerator initializes without errors
- [ ] Logo loaded (or text fallback used)
- [ ] Metadata table shows correct client/operation data
- [ ] Executive summary calculations accurate (success rate, duration)
- [ ] Technique table includes all techniques (or truncates with warning)
- [ ] Tactic coverage counts correctly
- [ ] PDF file created in correct directory
- [ ] Filename format correct: `{client}_{timestamp}.pdf`
- [ ] File size <5MB for 30-technique operation

### Edge Cases Handled
- [ ] Empty operation (0 techniques) â†’ Shows "No techniques executed"
- [ ] Missing operation data (None values) â†’ Shows "N/A"
- [ ] Large operation (1000+ techniques) â†’ Truncates with warning
- [ ] Logo file missing â†’ Uses text fallback
- [ ] Timeout protection works (raises TimeoutError after 60s)
- [ ] Division by zero avoided (success rate = 0.0% for empty ops)

### Git Workflow
- [ ] Each function committed separately
- [ ] Commit messages follow conventional commits format
- [ ] All commits pushed to feature branch
```

***

## Next Steps After Step 3 Complete

```bash
# Once pdf_generator.py tests all pass:

# STEP 4: Report Service (1 hour)
# - Create report_svc.py (REST API endpoint handler)
# - Integrates with pdf_generator.py

# STEP 5: Hook Registration (30 min)
# - Create hook.py (Caldera plugin registration)
# - Register REST API route

# STEP 6: Integration with Orchestrator (30 min)
# - Hook into orchestrator's post_operation_finish
# - Auto-generate PDFs when operations complete

# STEP 7: Integration Testing (30 min)
# - End-to-end test: operation â†’ PDF generation
# - Test REST API endpoint

# STEP 8: Merge & Tag (15 min)
# - Merge to main
# - Tag: v0.2.0-reporting
```

Only additions needed (5 minutes):

    Add gc.collect() in _generate_pdf_sync() (2 lines)

    Add psutil memory check (optional, 5 lines)
